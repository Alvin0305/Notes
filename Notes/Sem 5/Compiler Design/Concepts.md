#### Parse Tree
- A tree representation of the grammar structure of the source code
- Each interior node corresponds to a non terminal in the grammar
- Each leaf node corresponds to a terminal or ϵ in the grammar
- Shows every detail of the derivation, including parenthesis and grammar rules
- The root of the tree is labelled by the start symbol
- If a step in a derivation replaces A by XYZ, the parse tree has a corresponding internal node A with children labelled XYZ from left to right
- The leaves of the parse tree read from left to right is called the ==yield== or ==frontier== of the parse tree

>[!example]
>sum = num + 10;
>- stmt -> id = expr
>- expr -> expr + expr | expr \* expr | id | num
>
>```
>Parse Tree
>		stmt
>	   /    \
>	 id     expr
>	      /  |  \
>	    expr +  expr
>	     |       |
>	     id     num
>```
#### Abstract Syntax Tree (AST)
- A simplified version of parse tree that omits unnecessary grammar details
- Represents the abstract syntactic structure of the program, focusing only on the essential hierarchy of operations

>[!example]
>sum = num + 10;
>- stmt -> id = expr
>- expr -> expr + expr | expr \* expr | id | num
>```
>Abstract Syntax Tree
>		=
>	  /    \
>	sum     +
>		  /  \
>		num   10
>```
#### Symbol Table
- A data structure maintained by the compiler to store information about the identifiers (variables, functions, classes etc...) in the program
- Information stored includes
	- Name of the identifier
	- Type(int, float, ...)
	- Scope(local, global)
	- Memory location/address
	- Size
- Acts as a dictionary for the compiler during semantic analysis and code generation
#### Intermediate Representation (IR)
- A form of program that lies between the source code and the target machine code
- Designed to be easy to analyze and optimize, independent of the source and target machine.

>[!example]
>- Three Address Code
>- AST
#### Three Address Code
- A type of IR
- Each instruction has at most 3 addresses
	- typically two sources and one destination
- Looks like assembly, but is machine independent

>[!example]
>3 address code for **x = sum + i \* 10** is:
>- t1 = i \* 10
>- t2 = sum + t1
>- x = t2
> 
> This is machine independant
> 
> - LD R1, i
> - MUL R1, #10
> - LD R2, sum
> - ADD R1, R2
> - ST x, R1
>   
> This is the machine code (machine dependant)
#### Context Free Grammar (CFG)
- G = (N, T, P, S)
- N: set of non terminals
- T: set of terminals
- P: set of production rules
- S: start symbol

- Each production is of the form $A \to \alpha$
	- A is a non terminal
	- $\alpha$ is a string of zero or more terminals and non terminals
- A is called the head of the production
- $\alpha$ is called the body of the production

>[!example]
>S -> if (E) S else S | id = E
>E -> E + E | id
>
>- N = {S, E}
>- T = {if, (, ), else, id, =, +}
>- S = S
#### Derivation
- Derivation of a string begins with the start symbol
- A step of derivation replaces a non-terminal with the body of the production for the non-terminal
- A string of terminals that can be derived from the start symbol form the language defined by the grammar

>[!example]
>string: id = id + id
>S -> id = E
>E -> E + E | id
>
>S => id = E => id = E + E => id = id + E => id = id + id
>i.e., S =>* id = id + id
>
>=>\*: derives in zero or more steps 

- There are two types of derivation:
	- [[#Left most derivation]]
	- [[#Right most derivation]]
#### Left most derivation
- Always expand the left most non-terminal first
>[!example]
>Doing a left most derivation:
>- stmt => if (expr) stmt; else stmt;
>- => if (expr relop expr) stmt; else stmt;
>- => if (id relop expr) stmt; else stmt;
>- => if (id relop id) stmt; else stmt;
>- => if (id relop id) id = id; else stmt;
>- => if (id relop id) id = id; else id = id;
#### Right most derivation
- Always expand the right most non-terminal first

> [!example]
> Doing a right most derivation:
>- stmt => if (expr) stmt; else stmt;
>- => if (expr) stmt; else id = id;
>- => if (expr) id = id; else id = id;
>- => if (expr relop expr) id = id; else id = id;
>- => if (expr relop id) id = id; else id = id;
>- => if (id relop id) id = id; else id = id;
#### Sentential Form
- If S =>\* $\alpha$, then $\alpha$ is a sentential form
- A sentential form may contain for terminals and non-terminals and may be empty
#### Sentence
- Sentence is a [[#Sentential Form]] with only terminals
#### Language
- L(G), the language generated by the grammar G is the set of [[#Sentence|sentences]] derivable from the start symbol of G
- A string of terminals $w \in L(G)$ iff S =>\* w
#### Ambiguous Grammar
- A grammar that produces more than one parse tree for the same sentence is called ***ambiguous grammar***

>[!example]
>E -> E + E | E \* E | id
>string: id + id \* id
>
>```
>	    E                              E
>	  / | \                          / | \
>	 E  +  E                        E  *  E
>	 |   / | \                    / | \   |
>	id  E  *  E                  E  +  E  id
>	   |      |                  |     |
>	   id    id                 id    id
>
>```
#### Notations
- u, v, w, ... -> string of terminals
- $\alpha, \beta, \gamma$ -> strings of non-terminals and terminals
#### FIRST
- If α is a string of grammar symbols, FIRST(α) is the set of terminal symbols that can begin strings derivable from α
- i.e., it contains set of all terminals with which the string derivable from α can begin

>[!example]
>- FIRST(ab) = {a}
>- FIRST(b) = {b}

>[!important] 
>1. If a is a terminal, then FIRST(a) = {a}
>2. FIRST(ε) = ε
>3. If a is a non-terminal A:
>	- For each production A -> $X_1X_2...X_n$:
>		- Add FIRST($X_1$) to FIRST(A)
>		- If FIRST($X_1$) contains ε, then also add FIRST($X_2$), and so on.
>		- If all $X_i$ can derive ε, then add ε to FIRST(A)

>[!example] 
>S -> AB
>A -> aA | ε
>B -> bB | ε
>
>FIRST(AB) = {a, b, ε}
>FIRST(aA) = {a, ε}
>FIRST(bB) = {b, ε}
>FIRST(B) = {b, ε}
>FIRST(A) = {a, ε}
>FIRST(S) = {a, b, ε}

>[!example] 
>S -> (AB)
>A -> b | ε
>B -> c | ε
>
>FIRST((AB)) = {(}
>FIRST(A) = {b, ε}
>FIRST(B) = {c, ε}
>FIRST(S) = {(}

>[!example] 
>S -> AB
>A -> b | ε
>B -> c | ε
>
>FIRST(AB) = {b, c, ε}
>FIRST(A) = {b, ε}
>FIRST(B) = {c, ε}
>FIRST(S) = {b, c, ε}
#### FOLLOW
- When, there is a ε production in the grammar, FIRST is not enough to populate the parsing table. 
- FOLLOW(A) of a non-terminal A is the set of terminals that can appear immediately to the right of A in some valid derivation from the start symbol

>[!important] 
>1. Place $ in FOLLOW(S) (where S is the start symbol)
>2. For each production A -> aAβ:
>	- Add FIRST(β) - {ε} to FOLLOW(B)
>3. For each production A -> αB or A -> αBβ where ε ∈ FIRST(β)
>	- Add FOLLOW(A) to FOLLOW(B)

>[!example] 
>S -> (A)
>A -> Cd
>C -> ab | ε 
>
>FOLLOW(A) = {)}
>FOLLOW(C) = {d}
>FOLLOW(S) = {$}

>[!example] 
>S -> AB
>A -> aA | ε
>B -> bB | ε
>
>FOLLOW(S) = {\$}
>FOLLOW(A) = {b, \$}
>FOLLOW(B) = {\$}

>[!example] 
>S -> (AB)
>A -> b | ε
>B -> c | ε
>
>FOLLOW(S) = {\$}
>FOLLOW(A) = {c, )}
>FOLLOW(B) = {)}

>[!example] 
>S -> AB
>A -> b | ε
>B -> c | ε
>
>FOLLOW(S) = {\$}
>FOLLOW(A) = {c, \$}
>FOLLOW(B) = {\$}

>[!example] 
>S -> (A)
>A -> BC
>B -> b | ε
>C -> c | ε
>
>FOLLOW(S) = {\$}
>FOLLOW(A) = {)}
>FOLLOW(B) = {c, )}
>FOLLOW(C) = {)}

>[!example] 
>A -> BC
>B -> b | ε
>C -> c | ε
>
>FOLLOW(A) = {\$}
>FOLLOW(B) = {c, $}
>FOLLOW(C) = {\$}
#### Left Recursive Grammar
- Grammar which contains productions involving recursion in the starting

>[!example] 
>A -> Aa | b

- left recursive grammar results in multiple entries in parsing table, thus is not LL(1).
- But left recursive grammars can be converted to right recursive grammars
#### Conversion of Left Recursive to Right Recursive Grammar
Any left recursive grammar of the form A -> Aα | β can be converted to equivalent right recursive grammar as:
- A -> βA'
- A' -> αA' | ε

>[!example] 
>A -> Aa | b
>- A -> bA'
>- A' -> aA' | ε

>[!example] 
>E -> E + T | T
>T -> id
>
>- E -> TE'
>- E' -> +TE' | ε
>- T -> id

>[!example] 
>E -> E + T | T
>T -> T \* F | F
>F -> (E) | id
>- E -> TE'
>- E' -> +TE' | ε
>- E -> FT'
>- T' -> \*FT' | ε
>- F -> (E) | id
#### Reduction
- replaces a substring matching the body of a production by its head (the reverse of a step in a derivation)
- Given A -> α, substring α in a right-sentential form is reduced to A to get the previous right-sentential form
- The substring chosen for reduction is known as the [[#Handle]]
#### Handle
- A handle of a right-sentential form γ is a production A -> β and a position in γ where β may be found, such that replacing β at the position by A, produces the previous right-sentential form
	- For convenience, often the body β is referred to as the handle instead of A -> β.
#### Handle Pruning
- Doing a right most derivation in reverse, starting with the input string of terminals w to be parsed.
- If w is a sentence, w = $\gamma_n$, then n-th right-sentential form in a derivation of w
	- S = $\gamma_0$ => $\gamma_1$ => $\gamma_2$ => ... $\gamma_{n - 1}$ => $\gamma_n$ = w
- Handle pruning starts with reducing a handle $A_n \to \beta_n$ in $\gamma_n$ to obtain the previous right-sentential form $\gamma_{n - 1}$ 
- Reduction steps are repeated with $\gamma_{n - 1}$ and with the sentential forms resulting from successive steps, till the sentential form $\gamma_0$ = S is obtained or till the parser detects an error
#### Item
- An item, is a production with a dot at some position indicating how much of the production is already seen by the parser
- e.g., S -> L.=R
	- indicates that, the parser has seen a string derivable from L and is expecting to see a string derivable from =R

| Item      | Parser State                                                                                      |
| --------- | ------------------------------------------------------------------------------------------------- |
| S -> .L=R | Expecting to see a string derivable from L=R                                                      |
| S -> L.=R | A string derivable from L is read from the input. <br>Expecting to see a string derivable from =R |
| S -> L=.R | A string derivable from L= is read from the input.<br>Expecting to see a string derivable from R  |
| S -> L=R. | A string derivable from L=R is read from the input.<br>Parser can reduce by S -> L = R            |
#### State of parser
A parser state is represented by a set of [[#LR(0) Item|LR(0)]] items
- A -> α.β in a state indicates that the parser has already seen a string derivable from α, and is expecting to see a string derivable from β
- A -> αβ. in a state indicates that the parser has already seen the entire right hand side of the production(may lead to a reduction by A -> αβ) 
#### Closure of set of items
For a set of items I, Closure(I) is computed as follows:
- Add every item in I to Closure(I)
- If A -> α.Bβ is in Closure(I) then for each production B -> γ, add B -> .γ to Closure(I)
- Repeat the above step until no more new items can be added to Closure(I)

>[!example] 
>S' -> S
>S -> L = R
>L -> id
>R -> num
>
>Closure({S -> .L=R}) = {S -> .L=R, L -> .id}
>Closure({S -> L=.R}) = {S -> L=.R, R -> .num}
>Closure({S' -> .S}) = {S' -> .S, S -> .L = R, L -> .id}

>[!example] 
>E' -> E
>E -> E + T | T
>T -> id
>
>Closure({E -> .E + T}) = {E -> .E + T, E -> .T, T -> .id}
#### Goto
- Goto(I, X) where I is a set of items and X is a grammar symbol is defined to be the closure of the set of all items A -> αX.β such that A -> α.Xβ is in I

>[!example] 
>S' -> S
>S -> L = R
>L -> id
>R -> num
>
>Goto({S -> L.=R}, =) = {S -> L=.R, R -> .num}

>[!example] 
>E' -> E
>E -> E + T | T
>T -> id
>
>Goto({E -> E.+T}, +) = {E -> E+.T, T -> .id}
>Goto({E -> E+.T, T -> .id}, T) = {E -> E + T.}
#### LR(0) Item
- An item of the form A -> α.β is known as LR(0) item.
- A state of the parser is defined by a set of LR(0) items.
#### Augmented Grammar
- Adding a new state S' and a production S' -> S results in an augmented grammar
- The new production is added to indicate acceptance
	- Parser accepts when it is about to reduce by S' -> S

>[!example] 
>S -> L = R
>L -> id
>R -> num
>
>the corresponding augmented grammar is:
>
>- S' -> S
>- S -> L = R
>- L -> id
>- R -> num
#### LR(0) Automaton
- Each state represented by a set of LR(0) items
- Initial State is Closure({S' -> .S})
- State Transitions given by the [[#Goto|GOTO()]] functions

>[!note]
>The collection of sets of LR(0) items is known as the Canonical LR(0) collection 

>[!example] 
>S' -> S
>S -> L = R
>L -> id
>R -> num

![[LR(0) Automaton Example 1.png]]
#### LR(0) Parsing Table
- The parsing table has two parts -> ACTION and GOTO
- For each state i, represented by set $I_i$:
	- If \[A -> α.aβ] ∈ $I_i$, and Goto($I_i$, a) = $I_j$, ACTION\[i, a] = $s_j$ (shift and go to state j)
	- If \[A -> α.] ∈ $I_i$, and A != S', ACTION\[i, a] = $r_j$ (reduce using production numbered j, assuming A -> α production is numbered as j) for each terminal a. Also set ACTION\[i, $] to $r_j$
	- If \[S' -> S.] ∈ $I_i$, set ACTION\[i, $] to accept
	- If Goto($I_i$, A) = $I_j$, set GOTO(i, A) = j
	- All undefined entries are marked as error (blank)

>[!question] 
>0: S' -> S
>1: S -> L = R
>2: L -> id
>3: R -> num

![[LR(0) Automaton Example 1.png]]

| State | id  | =   | num | $   | L   | R   | S   |
| -- | --- | --- | --- | --- | --- | --- | --- |
| 0     | s3  |     |     |     | 2   |     | 1   |
| 1     |     |     |     | acc |     |     |     |
| 2     |     | s4  |     |     |     |     |     |
| 3     | r2  | r2  | r2  | r2  |     |     |     |
| 4     |     |     | s5  |     |     | 6   |     |
| 5     | r3  | r3  | r3  | r3  |     |     |     |
| 6     | r1  | r1  | r1  | r1  |     |     |     |

>[!note] 
>$s_i$ -> shit and goto state i
>$r_i$ -> reduce using production numbered i
>blank entries -> error
#### SLR Parsing Table
- Compute C = $I_0, I_1, I_2, ...I_n$, the canonical collection of sets of LR(0) items.
- For each set $I_i$, the parser has a corresponding state i
- The parsing table has two parts - ACTION and GOTO. The entries for state i are as follows:
	- If \[A -> α.aβ] ∈ $I_i$, and Goto($I_i$, a) = $I_j$, ACTION\[i, a] = $s_j$ (shift and go to state j)
	- If \[A -> α.] ∈ $I_i$, and A != S', ACTION\[i, a] = $r_j$ (reduce using production numbered j, assuming A -> α production is numbered as j) ==for every terminal a ∈ FOLLOW(A)==
	- If \[S' -> S.] ∈ $I_i$, set ACTION\[i, $] to accept
	- If Goto($I_i$, A) = $I_j$, set GOTO(i, A) = j
	- All undefined entries are marked as error (blank)
#### Shift Reduce Conflict
- When there is a shift and reduce action in the same state it is called a shift reduce conflict
- Such grammars are not LR(0)

>[!example] 
>0: S' -> S
>1: S -> id = R
>2: R -> id + id
>3: R -> id

| State | id  | =   | +     | $   | S   | R   |
| ----- | --- | --- | ----- | --- | --- | --- |
| 0     | s1  |     |       |     | 6   |     |
| 1     |     | s2  |       |     |     |     |
| 2     | s3  |     |       |     |     | 7   |
| 3     | r3  | r3  | r3/s4 | r3  |     |     |
| 4     | s5  |     |       |     |     |     |
| 5     | r2  | r2  | r2    | r2  |     |     |
| 6     |     |     |       | acc |     |     |
| 7     | r1  | r1  | r1    | r1  |     |     |
- As we can see, there is a conflict for T\[s, +]. It can either shift or reduce. This is a shift reduce conflict

>[!example] 
>0: E' -> E
>1: E -> T + E
>2: E -> T
>3: T -> id

| State | id  | +     | $   | E   | T   |
| ----- | --- | ----- | --- | --- | --- |
| 0     | s1  |       |     | 5   | 2   |
| 1     | r3  | r3    | r3  |     |     |
| 2     | r2  | r2/s3 | r2  |     |     |
| 3     | s1  |       |     | 4   | 2   |
| 4     | r1  | r1    | r1  |     |     |
| 5     |     |       | acc |     |     |
- Here also, there is a shift-reduce conflict in T\[s, +]
#### Reduce Reduce Conflict
- When there is two reduce and reduce actions on different productions in the same state it is called a shift reduce conflict

>[!example] 
>0: S' -> S
>1: S -> L = L
>2: S -> id
>3: L -> id
>
>FOLLOW(S') = {\$}
>FOLLOW(S) = {\$}
>FOLLOW(L) = {=, \$}

| State | id  | =   | $      | S   | L   |
| ----- | --- | --- | ------ | --- | --- |
| 0     | s3  |     |        | 1   | 2   |
| 1     |     |     | accept |     |     |
| 2     |     | s4  |        |     |     |
| 3     |     | r3  | r2/r3  |     |     |
| 4     | s6  |     |        |     | 5   |
| 5     |     |     | r1     |     |     |
| 6     |     | r3  | r3     |     |     |
- Since the $ is in both FOLLOW(S) and FOLLOW(L), there is a reduce reduce conflict in T\[3, \$]
- So, this is not SLR
#### LR(1) Items
- An LR(1) item has 2 components
	- first component is similar to LR(0) item
	- the second component is the look ahead of the item
- Items are of the form \[A -> α.β, a]
	- a is a look ahead symbol (a is either terminal or the right end marker $)
- \[A -> α., a] in a state indicates that the symbol a can follow handle α for which there is a possible reduction to A
	- reduction by A -> α only if the look ahead is a
- The first component is called the core of the state and the second component is the look ahead
#### Merging States
- We merge the states with same core but different look ahead by merging the look aheads

>[!example] 
>- {\[A -> a.A, \$], \[A -> .aA, \$], \[A -> .b, \$]}
>- {\[A -> a.A, a|b], \[A -> .Aa, a|b], \[A -> .b, a|b]}
>
>When we merge the two states into a single LALR state
>- {\[A -> a.A, a|b|\$], \[A -> .aA, a|b|\$], \[A -> .b, a|b|\$]}
#### Viable Prefix
- A prefix of a right sentential form that can appear on the stack of a shift reduce parser.
- The prefix does not extend part the right end of the right most handle
- Not all prefixes of the right sentential forms can be viable prefixes
	- when a handle appears in the stack, the parser reduces without shifting any more symbols

