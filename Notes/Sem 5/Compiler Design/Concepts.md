#### Parse Tree
---
- A tree representation of the grammar structure of the source code
- Each interior node corresponds to a non terminal in the grammar
- Each leaf node corresponds to a terminal or ϵ in the grammar
- Shows every detail of the derivation, including parenthesis and grammar rules
- The root of the tree is labelled by the start symbol
- If a step in a derivation replaces A by XYZ, the parse tree has a corresponding internal node A with children labelled XYZ from left to right
- The leaves of the parse tree read from left to right is called the ==yield== or ==frontier== of the parse tree

>[!example]
>sum = num + 10;
>- stmt -> id = expr
>- expr -> expr + expr | expr \* expr | id | num
>
>```
>Parse Tree
>		stmt
>	   /    \
>	 id     expr
>	      /  |  \
>	    expr +  expr
>	     |       |
>	     id     num
>```
#### Abstract Syntax Tree (AST)
---
- A simplified version of parse tree that omits unnecessary grammar details
- Represents the abstract syntactic structure of the program, focusing only on the essential hierarchy of operations

>[!example]
>sum = num + 10;
>- stmt -> id = expr
>- expr -> expr + expr | expr \* expr | id | num
>```
>Abstract Syntax Tree
>		=
>	  /    \
>	sum     +
>		  /  \
>		num   10
>```
#### Symbol Table
---
- A data structure maintained by the compiler to store information about the identifiers (variables, functions, classes etc...) in the program
- Information stored includes
	- Name of the identifier
	- Type(int, float, ...)
	- Scope(local, global)
	- Memory location/address
	- Size
- Acts as a dictionary for the compiler during semantic analysis and code generation
#### Intermediate Representation (IR)
---
- A form of program that lies between the source code and the target machine code
- Designed to be easy to analyze and optimize, independent of the source and target machine.

>[!example]
>- Three Address Code
>- AST

#### Three Address Code
---
- A type of IR
- Each instruction has at most 3 addresses
	- typically two sources and one destination
- Looks like assembly, but is machine independent

>[!example]
>3 address code for **x = sum + i \* 10** is:
>- t1 = i \* 10
>- t2 = sum + t1
>- x = t2
> 
> This is machine independant
> 
> - LD R1, i
> - MUL R1, #10
> - LD R2, sum
> - ADD R1, R2
> - ST x, R1
>   
> This is the machine code (machine dependant)
#### Context Free Grammar (CFG)
---
- G = (N, T, P, S)
- N: set of non terminals
- T: set of terminals
- P: set of production rules
- S: start symbol

- Each production is of the form $A \to \alpha$
	- A is a non terminal
	- $\alpha$ is a string of zero or more terminals and non terminals
- A is called the head of the production
- $\alpha$ is called the body of the production

>[!example]
>S -> if (E) S else S | id = E
>E -> E + E | id
>
>- N = {S, E}
>- T = {if, (, ), else, id, =, +}
>- S = S
#### Derivation
---
- Derivation of a string begins with the start symbol
- A step of derivation replaces a non-terminal with the body of the production for the non-terminal
- A string of terminals that can be derived from the start symbol form the language defined by the grammar

>[!example]
>string: id = id + id
>S -> id = E
>E -> E + E | id
>
>S => id = E => id = E + E => id = id + E => id = id + id
>i.e., S =>* id = id + id
>
>=>\*: derives in zero or more steps 

- There are two types of derivation:
	- [[#Left most derivation]]
	- [[#Right most derivation]]
#### Left most derivation
---
- Always expand the left most non-terminal first
>[!example]
>Doing a left most derivation:
>- stmt => if (expr) stmt; else stmt;
>- => if (expr relop expr) stmt; else stmt;
>- => if (id relop expr) stmt; else stmt;
>- => if (id relop id) stmt; else stmt;
>- => if (id relop id) id = id; else stmt;
>- => if (id relop id) id = id; else id = id;
#### Right most derivation
---
- Always expand the right most non-terminal first

> [!example]
> Doing a right most derivation:
>- stmt => if (expr) stmt; else stmt;
>- => if (expr) stmt; else id = id;
>- => if (expr) id = id; else id = id;
>- => if (expr relop expr) id = id; else id = id;
>- => if (expr relop id) id = id; else id = id;
>- => if (id relop id) id = id; else id = id;
#### Sentential Form
---
- If S =>\* $\alpha$, then $\alpha$ is a sentential form
- A sentential form may contain for terminals and non-terminals and may be empty

#### Sentence
---
- Sentence is a [[#Sentential Form]] with only terminals
#### Language
---
- L(G), the language generated by the grammar G is the set of [[#Sentence|sentences]] derivable from the start symbol of G
- A string of terminals $w \in L(G)$ iff S =>\* w
#### Ambiguous Grammar
---
- A grammar that produces more than one parse tree for the same sentence is called ***ambiguous grammar***

>[!example]
>E -> E + E | E \* E | id
>string: id + id \* id
>
>```
>	    E                              E
>	  / | \                          / | \
>	 E  +  E                        E  *  E
>	 |   / | \                    / | \   |
>	id  E  *  E                  E  +  E  id
>	   |      |                  |     |
>	   id    id                 id    id
>
>```

#### Notations
---
- u, v, w, ... -> string of terminals
- $\alpha, \beta, \gamma$ -> strings of non-terminals and terminals
#### FIRST
---
- If α is a string of grammar symbols, FIRST(α) is the set of terminal symbols that can begin strings derivable from α
- i.e., it contains set of all terminals with which the string derivable from α can begin

>[!example]
>- FIRST(ab) = {a}
>- FIRST(b) = {b}

>[!important] 
>1. If a is a terminal, then FIRST(a) = {a}
>2. FIRST(ε) = ε
>3. If a is a non-terminal A:
>	- For each production A -> $X_1X_2...X_n$:
>		- Add FIRST($X_1$) to FIRST(A)
>		- If FIRST($X_1$) contains ε, then also add FIRST($X_2$), and so on.
>		- If all $X_i$ can derive ε, then add ε to FIRST(A)

>[!example] 
>S -> AB
>A -> aA | ε
>B -> bB | ε
>
>FIRST(AB) = {a, b, ε}
>FIRST(aA) = {a, ε}
>FIRST(bB) = {b, ε}
>FIRST(B) = {b, ε}
>FIRST(A) = {a, ε}
>FIRST(S) = {a, b, ε}

>[!example] 
>S -> (AB)
>A -> b | ε
>B -> c | ε
>
>FIRST((AB)) = {(}
>FIRST(A) = {b, ε}
>FIRST(B) = {c, ε}
>FIRST(S) = {(}

>[!example] 
>S -> AB
>A -> b | ε
>B -> c | ε
>
>FIRST(AB) = {b, c, ε}
>FIRST(A) = {b, ε}
>FIRST(B) = {c, ε}
>FIRST(S) = {b, c, ε}
#### FOLLOW
---
- When, there is a ε production in the grammar, FIRST is not enough to populate the parsing table. 
- FOLLOW(A) of a non-terminal A is the set of terminals that can appear immediately to the right of A in some valid derivation from the start symbol

>[!important] 
>1. Place $ in FOLLOW(S) (where S is the start symbol)
>2. For each production A -> aAβ:
>	- Add FIRST(β) - {ε} to FOLLOW(B)
>3. For each production A -> αB or A -> αBβ where ε ∈ FIRST(β)
>	- Add FOLLOW(A) to FOLLOW(B)

>[!example] 
>S -> (A)
>A -> Cd
>C -> ab | ε 
>
>FOLLOW(A) = {)}
>FOLLOW(C) = {d}
>FOLLOW(S) = {$}

>[!example] 
>S -> AB
>A -> aA | ε
>B -> bB | ε
>
>FOLLOW(S) = {\$}
>FOLLOW(A) = {b, \$}
>FOLLOW(B) = {\$}

>[!example] 
>S -> (AB)
>A -> b | ε
>B -> c | ε
>
>FOLLOW(S) = {\$}
>FOLLOW(A) = {c, )}
>FOLLOW(B) = {)}

>[!example] 
>S -> AB
>A -> b | ε
>B -> c | ε
>
>FOLLOW(S) = {\$}
>FOLLOW(A) = {c, \$}
>FOLLOW(B) = {\$}

>[!example] 
>S -> (A)
>A -> BC
>B -> b | ε
>C -> c | ε
>
>FOLLOW(S) = {\$}
>FOLLOW(A) = {)}
>FOLLOW(B) = {c, )}
>FOLLOW(C) = {)}

>[!example] 
>A -> BC
>B -> b | ε
>C -> c | ε
>
>FOLLOW(A) = {\$}
>FOLLOW(B) = {c, $}
>FOLLOW(C) = {\$}

#### Left Recursive Grammar
---
- Grammar which contains productions involving recursion in the starting

>[!example] 
>A -> Aa | b

- left recursive grammar results in multiple entries in parsing table, thus is not LL(1).
- But left recursive grammars can be converted to right recursive grammars

#### Conversion of Left Recursive to Right Recursive Grammar
---
Any left recursive grammar of the form A -> Aα | β can be converted to equivalent right recursive grammar as:
- A -> βA'
- A' -> αA' | ε

>[!example] 
>A -> Aa | b
>- A -> bA'
>- A' -> aA' | ε

>[!example] 
>E -> E + T | T
>T -> id
>
>- E -> TE'
>- E' -> +TE' | ε
>- T -> id

>[!example] 
>E -> E + T | T
>T -> T \* F | F
>F -> (E) | id
>- E -> TE'
>- E' -> +TE' | ε
>- E -> FT'
>- T' -> \*FT' | ε
>- F -> (E) | id

